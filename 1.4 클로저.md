# 리액트 개발을 위해 꼭 알아야 할 자바스크립트

## 1.4 클로저

### 1.4.1 클로저의 정의

> 클로저란? 함수와 함수가 선언된 어휘적 환경의 조합

```javascript
function add() {
    const a = 10
    function innerAdd() {
        const b = 20
        console.log(a + b)
    }
    innerAdd() // 30
}

add()
```
a 변수의 유효 범위는 add 전체이고, b의 유효 범위는 innerAdd의 전체이다. innerAdd는 add 내부에서 선언되어 있기에 a를 사용할 수 있다. 즉, "선언된 어휘적 환경"이라는 것은, 변수가 코드 내부에서 어디서 선언됐는지를 말하는 것이다.

### 1.4.2 변수의 유효 범위, 스코프

> 스코프란? 변수의 유효 범위로, 자바스크립트에는 다양한 스코프가 있다.

**전역 스코프**
> 전역 레벨에서 선언하는 것을 전역 스코프라고 한다.

브라우저 환경에서 전역 객체는 window, Node.js 환경에서는 global이 있는데, 이 객체에 전역 레벨에서 선언한 스코프가 반영된다.

```javascript
var global = 'wow'

function wow() {
    console.log(global)
}

console.log(global) // wow
hello() // wow
console.log(global === window.global) // true
```

**함수 스코프**
다른 언어와 달리 자바 스크립트는 기본적으로 함수 레벨 스코프를 따른다. 즉, {} 블록이 스코프 범위를 결정하지 않는다.

```javascript
if (true) {
    var global = 'global scope'
}
console.log(global) // 'global scope'
console.log(global === window.global) // true
```
var global은 분명 {} 내부에 선언되었지만 밖에서도 접근이 가능하다. 즉 자바스크립트는 {} 기준이 아닌 함수 레벨 기준으로 스코프를 가지고 있다.


```javascript
function hello() {
    var local = 'local variable'
    console.log(local-) // local variable
}
hello()
console.log(local) // Uncaught ReferenceError: local is not defined
```
if 와는 다르게 함수 블록 내부에서는 외부에서 접근이 불가능하다. 자바스크립트는 함수 스코프를 따르기 때문이다.


```javascript
var x = 10

function foo() {
    var x = 100
    console.log(x) // 100
    function bar() {
        var x = 1000
        console.log(x) // 1000
    }
    bar()
}

console.log(x) // 10
foo()
```
자바스크립트에서는 가장 가까운 스코프에서 변수가 존재하는지 확인하기에 다음과 같은 결과가 나온 것을 볼 수 있다.


### 1.4.3 클로저의 활용
```javascript
var counter = 0

function handleClickQ {
    counter++
}
```
위 counter는 전역 레벨에 선언되어 있어 어디서든 접근해 수정할 수 있다. 이는 잠재적인 오류를 범한다.

```javascript
function Counter() {
    var counter = 0
    
    return {
        increase: function () {
            return ++counter
        },
        decrease: function () {
            return --counter
        },
        counter: function () {
            console.log('counter에 접근!')
            return counter
        },
    }
}
var c = Counter()
console.log(c.increase()) // 1
console.log(c.increase()) // 2
console.log(c.increase()) // 3
console.log(c.decrease()) // 2
console.log(c.counter()) // 2
```

counter 변수를 직접적으로 노출하지 않음으로써 사용자가 직접 수정하는 것을 막았다.


**리액트에서의 클로저**

```javascript
function Component() {
    const [state, setstate] = useState()
    function handleClick() {
        setState((prev) => prev + 1)
    }

    return <button onClick={handleClick}>Increment</button>;
}
```

useState가 반환하는 상태 업데이트 함수(setCount)는 클로저를 사용하여 상태 값이 저장된 공간을 참조한다. 그래서 컴포넌트가 여러 번 렌더링된 후에도 setCount 함수는 이전 상태 값을 잊지 않고, 그 값을 바탕으로 업데이트 작업을 수행할 수 있다. 이는 함수의 스코프 안에서 선언된 변수를 기억하는 클로저의 특성 덕분이다.

### 1.4.4 주의할 점

```javascript
for (var i = 0; i < 5; i++) {
    setTimeout(function () {
        console.log(i)
    }, i * 1000)
}
```

위 코드의 결과는 5만 모두 출력 됨. i가 var로 선언되었고, var는 함수 레벨 스코프를 따르되, 전역일 경우 global에 들어감. 위 경우, 5번 반복후 setTimeout이 끝나 log를 찍는 시점에서 i는 5로 되어있기에 5로 출력되는 것이다.

```javascript
for (let i = 0; i < 5; i++) {
    setTimeout(function () {
        console.log(i)
    }, i * 1000)
}
```

위 코드의 결과는 의도대로 잘 작동한다. let으로 함수 레벨 스코프가 아닌 블록 스코프를 갖도록 하였기에 i가 바뀔 때마다 새로운 스코프 블럭의 i 값이 바뀌는 것으로 한 블럭에 대한 i는 영향을 미치지 않는다.

